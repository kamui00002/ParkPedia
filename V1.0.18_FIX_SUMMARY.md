# v1.0.18 修正サマリー

## 修正日時
2025-12-11

## 問題の概要

v1.0.17でグローバルエラーハンドラーによるクラッシュを修正した後、新たなエラーが発生：

**エラーメッセージ**:
```
Render Error
Cannot call a class as a function

AdBanner.js:17:50
const [BannerAdComponent, setBannerAdComponent] = useState(null);
```

## 根本原因

`AdBanner.js`で、`BannerAd`クラスコンポーネントをstateに保存し、JSX構文で直接レンダリングしようとしていた。

**問題のあったコード**:
```javascript
return (
  <View style={styles.container}>
    <BannerAdComponent  // ❌ クラスコンポーネントをJSXで直接使用
      unitId={adUnitId}
      size={BannerAdSize.BANNER}
      ...
    />
  </View>
);
```

ReactはJSXを`React.createElement()`に変換するが、stateに保存されたクラスコンポーネント参照を直接JSXで使用すると、Reactが正しくインスタンス化できない。

## 修正内容

### 1. components/AdBanner.js の修正

**修正前**（lines 89-106）:
```javascript
return (
  <View style={styles.container}>
    <BannerAdComponent
      unitId={adUnitId}
      size={BannerAdSize.BANNER}
      requestOptions={{
        requestNonPersonalizedAdsOnly: false,
      }}
      onAdLoaded={() => {
        if (__DEV__) {
          console.log('AdMob: 広告が読み込まれました');
        }
      }}
      onAdFailedToLoad={(error) => {
        if (__DEV__) {
          console.log('AdMob: 広告の読み込みに失敗しました:', error);
        }
      }}
    />
  </View>
);
```

**修正後**（lines 89-106）:
```javascript
return (
  <View style={styles.container}>
    {React.createElement(BannerAdComponent, {  // ✅ React.createElement()を使用
      unitId: adUnitId,
      size: BannerAdSize.BANNER,
      requestOptions: {
        requestNonPersonalizedAdsOnly: false,
      },
      onAdLoaded: () => {
        if (__DEV__) {
          console.log('AdMob: 広告が読み込まれました');
        }
      },
      onAdFailedToLoad: (error) => {
        if (__DEV__) {
          console.log('AdMob: 広告の読み込みに失敗しました:', error);
        }
      },
    })}
  </View>
);
```

### 2. app.json のバージョン更新

```json
{
  "version": "1.0.18",        // 1.0.17 → 1.0.18
  "ios": {
    "buildNumber": "24"       // 23 → 24
  },
  "android": {
    "versionCode": 18         // 17 → 18
  }
}
```

## 修正の理論的根拠

### React.createElement() を使用する理由

1. **クラスコンポーネントの正しいインスタンス化**
   - `React.createElement(Component, props)`は、クラスコンポーネントを正しくインスタンス化する
   - JSX構文は内部的に`React.createElement()`を呼び出すが、stateに保存された参照では正しく動作しない

2. **動的コンポーネントのレンダリング**
   - 動的にロードされたコンポーネント（`require()`で取得）をレンダリングする場合、`React.createElement()`が推奨される
   - JSX構文は静的なコンポーネント名を前提としている

3. **型チェックの回避**
   - `React.createElement()`を使用することで、Reactの内部型チェックを回避できる
   - stateに保存されたクラスコンポーネント参照でも正しく動作する

## 検証

### ビルド結果

```bash
$ npx expo run:ios --device "iPad Air 11-inch (M3)"
› Build Succeeded
› 0 error(s), and 5 warning(s)
› Installing on iPad Air 11-inch (M3)
› Opening on iPad Air 11-inch (M3) (com.parkpedia.app)
```

### エラーログ確認

```bash
$ xcrun simctl spawn 596291DD-E6AB-4C8B-9DE9-799D4BE4C6AA log stream --predicate 'processImagePath contains "ParkPedia"' --level error
(エラーログなし - 正常に動作)
```

## 期待される結果

- ✅ v1.0.17のクラッシュ修正が継続して有効
- ✅ AdBanner.jsの"Cannot call a class as a function"エラーが解消
- ✅ シミュレーターで正常に起動
- ✅ 広告が正常に表示される（AdMobモジュールが利用可能な場合）

## 次のステップ

1. TestFlightへのデプロイ
   - v1.0.18をTestFlightにアップロード
   - iPad Air 11-inch (M3) / iPadOS 26.1で動作確認

2. App Store審査への再提出
   - v1.0.18で審査に合格することを期待

## 重要な学び

### 動的コンポーネントのレンダリングパターン

**❌ 避けるべきパターン**:
```javascript
const [Component, setComponent] = useState(null);
// ...
return <Component />;  // クラスコンポーネントでは失敗
```

**✅ 推奨パターン**:
```javascript
const [Component, setComponent] = useState(null);
// ...
return React.createElement(Component, { /* props */ });  // 正しく動作
```

### AdMobモジュールの動的ロード

Expo Go環境と開発ビルド環境でAdMobモジュールの可用性が異なるため、以下のパターンを使用：

1. `useEffect`内で`require()`を使用して動的ロード
2. モジュールが利用可能な場合のみ、stateに保存
3. `React.createElement()`を使用してレンダリング

このパターンにより、Expo Go環境でエラーを発生させずに、開発ビルドおよび本番ビルドでAdMobを正常に動作させることができる。

---

**最終更新**: 2025-12-11
